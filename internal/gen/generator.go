// Copyright 2025 Interlynk Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"unicode"
)

const (
	stringType = "string"
)

// Generator generates Go source code from an SPDX model.
type Generator struct {
	model   *Model
	pkgName string
	outDir  string
}

// NewGenerator creates a new Generator.
func NewGenerator(model *Model, pkgName, outDir string) *Generator {
	return &Generator{
		model:   model,
		pkgName: pkgName,
		outDir:  outDir,
	}
}

// Generate generates all Go source files.
func (g *Generator) Generate() error {
	if err := os.MkdirAll(g.outDir, 0750); err != nil {
		return fmt.Errorf("create output directory: %w", err)
	}

	if err := g.generateEnums(); err != nil {
		return fmt.Errorf("generate enums: %w", err)
	}

	if err := g.generateTypes(); err != nil {
		return fmt.Errorf("generate types: %w", err)
	}

	return nil
}

func (g *Generator) generateEnums() error {
	// Group enums by namespace
	enumsByNS := make(map[string][]*Enum)
	for _, enum := range g.model.Enums {
		ns := enum.Namespace
		if ns == "" {
			ns = "Core"
		}
		enumsByNS[ns] = append(enumsByNS[ns], enum)
	}

	// Sort namespaces for deterministic output
	namespaces := make([]string, 0, len(enumsByNS))
	for ns := range enumsByNS {
		namespaces = append(namespaces, ns)
	}
	sort.Strings(namespaces)

	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("// Code generated by spdx-gen. DO NOT EDIT.\n\npackage %s\n\n", g.pkgName))

	for _, ns := range namespaces {
		enums := enumsByNS[ns]
		sort.Slice(enums, func(i, j int) bool {
			return enums[i].Name < enums[j].Name
		})

		for _, enum := range enums {
			if err := g.writeEnum(&buf, enum); err != nil {
				return err
			}
		}
	}

	return g.writeFile("enums_gen.go", buf.Bytes())
}

func (g *Generator) writeEnum(buf *bytes.Buffer, enum *Enum) error {
	typeName := toGoName(enum.Name)

	// Write type comment and definition
	if enum.Comment != "" {
		fmt.Fprintf(buf, "// %s %s\n", typeName, formatComment(enum.Comment))
	}
	fmt.Fprintf(buf, "type %s string\n\n", typeName)

	// Sort values for deterministic output
	sort.Slice(enum.Values, func(i, j int) bool {
		return enum.Values[i].Name < enum.Values[j].Name
	})

	// Write const block
	buf.WriteString("const (\n")
	for _, val := range enum.Values {
		constName := typeName + toGoName(val.Name)
		if val.Comment != "" {
			fmt.Fprintf(buf, "\t// %s %s\n", constName, formatComment(val.Comment))
		}
		fmt.Fprintf(buf, "\t%s %s = %q\n", constName, typeName, val.Name)
	}
	buf.WriteString(")\n\n")

	// Write String method
	fmt.Fprintf(buf, "// String returns the string representation of %s.\n", typeName)
	fmt.Fprintf(buf, "func (v %s) String() string {\n\treturn string(v)\n}\n\n", typeName)

	// Write IsValid method
	fmt.Fprintf(buf, "// IsValid returns true if the value is a valid %s.\n", typeName)
	fmt.Fprintf(buf, "func (v %s) IsValid() bool {\n\tswitch v {\n", typeName)
	buf.WriteString("\tcase ")
	for i, val := range enum.Values {
		if i > 0 {
			buf.WriteString(", ")
		}
		buf.WriteString(typeName + toGoName(val.Name))
	}
	buf.WriteString(":\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n")

	return nil
}

func (g *Generator) generateTypes() error {
	// Build class hierarchy
	hierarchy := g.buildHierarchy()

	// Group classes by namespace, filtering out enum types
	classesByNS := make(map[string][]*Class)
	for id, class := range g.model.Classes {
		// Skip classes that are enum types
		if _, isEnum := g.model.Enums[id]; isEnum {
			continue
		}
		ns := class.Namespace
		if ns == "" {
			ns = "Core"
		}
		classesByNS[ns] = append(classesByNS[ns], class)
	}

	// Sort namespaces
	namespaces := make([]string, 0, len(classesByNS))
	for ns := range classesByNS {
		namespaces = append(namespaces, ns)
	}
	sort.Strings(namespaces)

	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("// Code generated by spdx-gen. DO NOT EDIT.\n\npackage %s\n\n", g.pkgName))
	buf.WriteString("import (\n\t\"time\"\n)\n\n")

	for _, ns := range namespaces {
		classes := classesByNS[ns]
		sort.Slice(classes, func(i, j int) bool {
			return classes[i].Name < classes[j].Name
		})

		for _, class := range classes {
			if err := g.writeClass(&buf, class, hierarchy); err != nil {
				return err
			}
		}
	}

	return g.writeFile("types_gen.go", buf.Bytes())
}

func (g *Generator) writeClass(buf *bytes.Buffer, class *Class, _ map[string][]string) error {
	typeName := toGoName(class.Name)

	// Write type comment
	if class.Comment != "" {
		fmt.Fprintf(buf, "// %s %s\n", typeName, formatComment(class.Comment))
	}
	if class.IsAbstract {
		fmt.Fprintf(buf, "// %s is an abstract type and should not be instantiated directly.\n", typeName)
	}

	fmt.Fprintf(buf, "type %s struct {\n", typeName)

	// Embed parent type if exists
	parentFields := make(map[string]bool) // track fields from parent to avoid duplicates
	if class.Parent != "" {
		parentName := extractName(class.Parent)
		if strings.HasPrefix(class.Parent, spdxBaseURI) {
			fmt.Fprintf(buf, "\t%s\n", toGoName(parentName))
			// Collect parent fields
			g.collectParentFields(class.Parent, parentFields)
		}
	}

	// Add spdxId for Element base type
	if class.Name == "Element" {
		buf.WriteString("\tSpdxID string `json:\"spdxId\"`\n")
	}

	// Track embedded type name
	embeddedTypeName := ""
	if class.Parent != "" {
		embeddedTypeName = toGoName(extractName(class.Parent))
	}

	// Write properties
	seenFields := make(map[string]bool)
	for _, prop := range class.Properties {
		fieldName := toGoName(prop.Name)

		// Skip if this field is inherited from parent
		if parentFields[fieldName] {
			continue
		}

		// Skip duplicate fields within the same class
		if seenFields[fieldName] {
			continue
		}
		seenFields[fieldName] = true

		// Handle collision with embedded type name
		if fieldName == embeddedTypeName {
			fieldName += "s" // pluralize to avoid collision
		}

		fieldType := g.resolveType(prop)
		jsonTag := prop.Name

		// Add omitempty for optional fields
		omitempty := ""
		if prop.MinCount == 0 {
			omitempty = ",omitempty"
		}

		// Determine if it's a slice
		if prop.MaxCount != 1 {
			fieldType = "[]" + fieldType
		}

		// Add pointer for optional non-slice reference types
		if prop.MinCount == 0 && prop.MaxCount == 1 && isReferenceType(fieldType) {
			fieldType = "*" + fieldType
		}

		// Build validation tag
		validateTag := g.buildValidateTag(prop)

		if validateTag != "" {
			fmt.Fprintf(buf, "\t%s %s `json:\"%s%s\" validate:\"%s\"`\n", fieldName, fieldType, jsonTag, omitempty, validateTag)
		} else {
			fmt.Fprintf(buf, "\t%s %s `json:\"%s%s\"`\n", fieldName, fieldType, jsonTag, omitempty)
		}
	}

	buf.WriteString("}\n\n")

	return nil
}

// buildValidateTag creates validation tags for a property.
func (g *Generator) buildValidateTag(prop *PropertyRef) string {
	var parts []string

	// Required field
	if prop.MinCount > 0 {
		parts = append(parts, "required")
	}

	// Min items for slices
	if prop.MinCount > 1 {
		parts = append(parts, fmt.Sprintf("min=%d", prop.MinCount))
	}

	// Max items for slices
	if prop.MaxCount > 1 {
		parts = append(parts, fmt.Sprintf("max=%d", prop.MaxCount))
	}

	// URL validation for anyURI types
	if prop.DataType == "http://www.w3.org/2001/XMLSchema#anyURI" {
		parts = append(parts, "omitempty,url")
	}

	return strings.Join(parts, ",")
}

// collectParentFields collects all field names from parent classes recursively.
func (g *Generator) collectParentFields(parentID string, fields map[string]bool) {
	parent, ok := g.model.Classes[parentID]
	if !ok {
		return
	}

	for _, prop := range parent.Properties {
		fields[toGoName(prop.Name)] = true
	}

	// Recurse to grandparent
	if parent.Parent != "" {
		g.collectParentFields(parent.Parent, fields)
	}
}

func (g *Generator) resolveType(prop *PropertyRef) string {
	// Check for class reference first
	if prop.ClassRef != "" {
		className := extractName(prop.ClassRef)
		return toGoName(className)
	}

	// Check for enum values (sh:in)
	if len(prop.InValues) > 0 {
		// Try to infer enum type from the first value
		firstVal := prop.InValues[0]
		if idx := strings.LastIndex(firstVal, "/"); idx > 0 {
			parentPath := firstVal[:idx]
			enumName := extractName(parentPath)
			return toGoName(enumName)
		}
	}

	// Map XSD datatypes to Go types
	switch prop.DataType {
	case "http://www.w3.org/2001/XMLSchema#string":
		return stringType
	case "http://www.w3.org/2001/XMLSchema#boolean":
		return "bool"
	case "http://www.w3.org/2001/XMLSchema#integer", "http://www.w3.org/2001/XMLSchema#positiveInteger", "http://www.w3.org/2001/XMLSchema#nonNegativeInteger":
		return "int"
	case "http://www.w3.org/2001/XMLSchema#decimal":
		return "float64"
	case "http://www.w3.org/2001/XMLSchema#dateTimeStamp":
		return "time.Time"
	case "http://www.w3.org/2001/XMLSchema#anyURI":
		return stringType
	default:
		// Check if it's an SPDX type
		if strings.HasPrefix(prop.DataType, spdxBaseURI) {
			return toGoName(extractName(prop.DataType))
		}
		return "interface{}"
	}
}

func (g *Generator) buildHierarchy() map[string][]string {
	hierarchy := make(map[string][]string)
	for _, class := range g.model.Classes {
		if class.Parent != "" {
			hierarchy[class.Parent] = append(hierarchy[class.Parent], class.ID)
		}
	}
	return hierarchy
}

func (g *Generator) writeFile(filename string, content []byte) error {
	// Format the generated code
	formatted, err := format.Source(content)
	if err != nil {
		// Write unformatted content for debugging
		path := filepath.Join(g.outDir, filename)
		if writeErr := os.WriteFile(path, content, 0600); writeErr != nil {
			return fmt.Errorf("write unformatted file: %w", writeErr)
		}
		return fmt.Errorf("format source: %w (unformatted written to %s)", err, path)
	}

	path := filepath.Join(g.outDir, filename)
	if err := os.WriteFile(path, formatted, 0600); err != nil {
		return fmt.Errorf("write file: %w", err)
	}

	return nil
}

// toGoName converts an SPDX name to a valid Go identifier.
func toGoName(name string) string {
	if name == "" {
		return ""
	}

	// Handle prefixed names (e.g., "software_packageVersion" -> "PackageVersion")
	if idx := strings.Index(name, "_"); idx >= 0 {
		prefix := name[:idx]
		rest := name[idx+1:]
		// Only strip common prefixes
		switch prefix {
		case "software", "security", "ai", "build", "dataset", "expandedlicensing", "simplelicensing", "extension":
			name = rest
		}
	}

	// Convert to PascalCase
	var result strings.Builder
	capitalizeNext := true

	for _, r := range name {
		if r == '_' || r == '-' || r == '.' {
			capitalizeNext = true
			continue
		}
		if capitalizeNext {
			result.WriteRune(unicode.ToUpper(r))
			capitalizeNext = false
		} else {
			result.WriteRune(r)
		}
	}

	return result.String()
}

// formatComment formats a comment for Go documentation.
func formatComment(comment string) string {
	// Replace newlines with spaces for single-line comments
	comment = strings.ReplaceAll(comment, "\n", " ")
	// Trim whitespace
	comment = strings.TrimSpace(comment)
	return comment
}

// isReferenceType returns true if the type should be a pointer when optional.
func isReferenceType(typeName string) bool {
	switch typeName {
	case "string", "bool", "int", "int64", "float64", "time.Time":
		return false
	default:
		return true
	}
}

var _ = template.New // Ensure template package is imported for future use
