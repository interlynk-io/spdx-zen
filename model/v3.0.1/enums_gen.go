// Code generated by spdx-gen. DO NOT EDIT.

package spdx

// EnergyUnitType Specifies the unit of energy consumption.
type EnergyUnitType string

const (
	// EnergyUnitTypeKilowattHour Kilowatt-hour.
	EnergyUnitTypeKilowattHour EnergyUnitType = "kilowattHour"
	// EnergyUnitTypeMegajoule Megajoule.
	EnergyUnitTypeMegajoule EnergyUnitType = "megajoule"
	// EnergyUnitTypeOther Any other units of energy measurement.
	EnergyUnitTypeOther EnergyUnitType = "other"
)

// String returns the string representation of EnergyUnitType.
func (v EnergyUnitType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid EnergyUnitType.
func (v EnergyUnitType) IsValid() bool {
	switch v {
	case EnergyUnitTypeKilowattHour, EnergyUnitTypeMegajoule, EnergyUnitTypeOther:
		return true
	default:
		return false
	}
}

// SafetyRiskAssessmentType Specifies the safety risk level.
type SafetyRiskAssessmentType string

const (
	// SafetyRiskAssessmentTypeHigh The second-highest level of risk posed by an AI system.
	SafetyRiskAssessmentTypeHigh SafetyRiskAssessmentType = "high"
	// SafetyRiskAssessmentTypeLow Low/no risk is posed by an AI system.
	SafetyRiskAssessmentTypeLow SafetyRiskAssessmentType = "low"
	// SafetyRiskAssessmentTypeMedium The third-highest level of risk posed by an AI system.
	SafetyRiskAssessmentTypeMedium SafetyRiskAssessmentType = "medium"
	// SafetyRiskAssessmentTypeSerious The highest level of risk posed by an AI system.
	SafetyRiskAssessmentTypeSerious SafetyRiskAssessmentType = "serious"
)

// String returns the string representation of SafetyRiskAssessmentType.
func (v SafetyRiskAssessmentType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid SafetyRiskAssessmentType.
func (v SafetyRiskAssessmentType) IsValid() bool {
	switch v {
	case SafetyRiskAssessmentTypeHigh, SafetyRiskAssessmentTypeLow, SafetyRiskAssessmentTypeMedium, SafetyRiskAssessmentTypeSerious:
		return true
	default:
		return false
	}
}

// AnnotationType Specifies the type of an annotation.
type AnnotationType string

const (
	// AnnotationTypeOther Used to store extra information about an Element which is not part of a review (e.g. extra information provided during the creation of the Element).
	AnnotationTypeOther AnnotationType = "other"
	// AnnotationTypeReview Used when someone reviews the Element.
	AnnotationTypeReview AnnotationType = "review"
)

// String returns the string representation of AnnotationType.
func (v AnnotationType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid AnnotationType.
func (v AnnotationType) IsValid() bool {
	switch v {
	case AnnotationTypeOther, AnnotationTypeReview:
		return true
	default:
		return false
	}
}

// ExternalIdentifierType Specifies the type of an external identifier.
type ExternalIdentifierType string

const (
	// ExternalIdentifierTypeCpe22 [Common Platform Enumeration Specification 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf)
	ExternalIdentifierTypeCpe22 ExternalIdentifierType = "cpe22"
	// ExternalIdentifierTypeCpe23 [Common Platform Enumeration: Naming Specification Version 2.3](https://csrc.nist.gov/publications/detail/nistir/7695/final)
	ExternalIdentifierTypeCpe23 ExternalIdentifierType = "cpe23"
	// ExternalIdentifierTypeCve Common Vulnerabilities and Exposures identifiers, an identifier for a specific software flaw defined within the official CVE Dictionary and that conforms to the [CVE specification](https://csrc.nist.gov/glossary/term/cve_id).
	ExternalIdentifierTypeCve ExternalIdentifierType = "cve"
	// ExternalIdentifierTypeEmail Email address, as defined in [RFC 3696](https://datatracker.ietf.org/doc/rfc3986/) Section 3.
	ExternalIdentifierTypeEmail ExternalIdentifierType = "email"
	// ExternalIdentifierTypeGitoid [Gitoid](https://www.iana.org/assignments/uri-schemes/prov/gitoid), stands for [Git Object ID](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects). A gitoid of type blob is a unique hash of a binary artifact. A gitoid may represent either an [Artifact Identifier](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-identifier-types) for the software artifact or an [Input Manifest Identifier](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#input-manifest-identifier) for the software artifact's associated [Artifact Input Manifest](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-input-manifest); this ambiguity exists because the Artifact Input Manifest is itself an artifact, and the gitoid of that artifact is its valid identifier. Gitoids calculated on software artifacts (Snippet, File, or Package Elements) should be recorded in the SPDX 3.0 SoftwareArtifact's contentIdentifier property. Gitoids calculated on the Artifact Input Manifest (Input Manifest Identifier) should be recorded in the SPDX 3.0 Element's externalIdentifier property. See [OmniBOR Specification](https://github.com/omnibor/spec/), a minimalistic specification for describing software [Artifact Dependency Graphs](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-dependency-graph-adg).
	ExternalIdentifierTypeGitoid ExternalIdentifierType = "gitoid"
	// ExternalIdentifierTypeOther Used when the type does not match any of the other options.
	ExternalIdentifierTypeOther ExternalIdentifierType = "other"
	// ExternalIdentifierTypePackageUrl Package URL, as defined in the corresponding [Annex](../../../annexes/pkg-url-specification.md) of this specification.
	ExternalIdentifierTypePackageUrl ExternalIdentifierType = "packageUrl"
	// ExternalIdentifierTypeSecurityOther Used when there is a security related identifier of unspecified type.
	ExternalIdentifierTypeSecurityOther ExternalIdentifierType = "securityOther"
	// ExternalIdentifierTypeSwhid SoftWare Hash IDentifier, a persistent intrinsic identifier for digital artifacts, such as files, trees (also known as directories or folders), commits, and other objects typically found in version control systems. The format of the identifiers is defined in the [SWHID specification](https://www.swhid.org/specification/v1.1/4.Syntax) (ISO/IEC DIS 18670). They typically look like `swh:1:cnt:94a9ed024d3859793618152ea559a168bbcbb5e2`.
	ExternalIdentifierTypeSwhid ExternalIdentifierType = "swhid"
	// ExternalIdentifierTypeSwid Concise Software Identification (CoSWID) tag, as defined in [RFC 9393](https://datatracker.ietf.org/doc/rfc9393/) Section 2.3.
	ExternalIdentifierTypeSwid ExternalIdentifierType = "swid"
	// ExternalIdentifierTypeUrlScheme [Uniform Resource Identifier (URI) Schemes](https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml). The scheme used in order to locate a resource.
	ExternalIdentifierTypeUrlScheme ExternalIdentifierType = "urlScheme"
)

// String returns the string representation of ExternalIdentifierType.
func (v ExternalIdentifierType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid ExternalIdentifierType.
func (v ExternalIdentifierType) IsValid() bool {
	switch v {
	case ExternalIdentifierTypeCpe22, ExternalIdentifierTypeCpe23, ExternalIdentifierTypeCve, ExternalIdentifierTypeEmail, ExternalIdentifierTypeGitoid, ExternalIdentifierTypeOther, ExternalIdentifierTypePackageUrl, ExternalIdentifierTypeSecurityOther, ExternalIdentifierTypeSwhid, ExternalIdentifierTypeSwid, ExternalIdentifierTypeUrlScheme:
		return true
	default:
		return false
	}
}

// ExternalRefType Specifies the type of an external reference.
type ExternalRefType string

const (
	// ExternalRefTypeAltDownloadLocation A reference to an alternative download location.
	ExternalRefTypeAltDownloadLocation ExternalRefType = "altDownloadLocation"
	// ExternalRefTypeAltWebPage A reference to an alternative web page.
	ExternalRefTypeAltWebPage ExternalRefType = "altWebPage"
	// ExternalRefTypeBinaryArtifact A reference to binary artifacts related to a package.
	ExternalRefTypeBinaryArtifact ExternalRefType = "binaryArtifact"
	// ExternalRefTypeBower A reference to a Bower package. The package locator format, looks like `package#version`, is defined in the "install" section of [Bower API documentation](https://bower.io/docs/api/#install).
	ExternalRefTypeBower ExternalRefType = "bower"
	// ExternalRefTypeBuildMeta A reference build metadata related to a published package.
	ExternalRefTypeBuildMeta ExternalRefType = "buildMeta"
	// ExternalRefTypeBuildSystem A reference build system used to create or publish the package.
	ExternalRefTypeBuildSystem ExternalRefType = "buildSystem"
	// ExternalRefTypeCertificationReport A reference to a certification report for a package from an accredited/independent body.
	ExternalRefTypeCertificationReport ExternalRefType = "certificationReport"
	// ExternalRefTypeChat A reference to the instant messaging system used by the maintainer for a package.
	ExternalRefTypeChat ExternalRefType = "chat"
	// ExternalRefTypeComponentAnalysisReport A reference to a Software Composition Analysis (SCA) report.
	ExternalRefTypeComponentAnalysisReport ExternalRefType = "componentAnalysisReport"
	// ExternalRefTypeCwe [Common Weakness Enumeration](https://csrc.nist.gov/glossary/term/common_weakness_enumeration). A reference to a source of software flaw defined within the official [CWE List](https://cwe.mitre.org/data/) that conforms to the [CWE specification](https://cwe.mitre.org/).
	ExternalRefTypeCwe ExternalRefType = "cwe"
	// ExternalRefTypeDocumentation A reference to the documentation for a package.
	ExternalRefTypeDocumentation ExternalRefType = "documentation"
	// ExternalRefTypeDynamicAnalysisReport A reference to a dynamic analysis report for a package.
	ExternalRefTypeDynamicAnalysisReport ExternalRefType = "dynamicAnalysisReport"
	// ExternalRefTypeEolNotice A reference to the End Of Sale (EOS) and/or End Of Life (EOL) information related to a package.
	ExternalRefTypeEolNotice ExternalRefType = "eolNotice"
	// ExternalRefTypeExportControlAssessment A reference to a export control assessment for a package.
	ExternalRefTypeExportControlAssessment ExternalRefType = "exportControlAssessment"
	// ExternalRefTypeFunding A reference to funding information related to a package.
	ExternalRefTypeFunding ExternalRefType = "funding"
	// ExternalRefTypeIssueTracker A reference to the issue tracker for a package.
	ExternalRefTypeIssueTracker ExternalRefType = "issueTracker"
	// ExternalRefTypeLicense A reference to additional license information related to an artifact.
	ExternalRefTypeLicense ExternalRefType = "license"
	// ExternalRefTypeMailingList A reference to the mailing list used by the maintainer for a package.
	ExternalRefTypeMailingList ExternalRefType = "mailingList"
	// ExternalRefTypeMavenCentral A reference to a Maven repository artifact. The artifact locator format is defined in the [Maven documentation](https://maven.apache.org/guides/mini/guide-naming-conventions.html) and looks like `groupId:artifactId[:version]`.
	ExternalRefTypeMavenCentral ExternalRefType = "mavenCentral"
	// ExternalRefTypeMetrics A reference to metrics related to package such as OpenSSF scorecards.
	ExternalRefTypeMetrics ExternalRefType = "metrics"
	// ExternalRefTypeNpm A reference to an npm package. The package locator format is defined in the [npm documentation](https://docs.npmjs.com/cli/v10/configuring-npm/package-json) and looks like `package@version`.
	ExternalRefTypeNpm ExternalRefType = "npm"
	// ExternalRefTypeNuget A reference to a NuGet package. The package locator format is defined in the [NuGet documentation](https://docs.nuget.org) and looks like `package/version`.
	ExternalRefTypeNuget ExternalRefType = "nuget"
	// ExternalRefTypeOther Used when the type does not match any of the other options.
	ExternalRefTypeOther ExternalRefType = "other"
	// ExternalRefTypePrivacyAssessment A reference to a privacy assessment for a package.
	ExternalRefTypePrivacyAssessment ExternalRefType = "privacyAssessment"
	// ExternalRefTypeProductMetadata A reference to additional product metadata such as reference within organization's product catalog.
	ExternalRefTypeProductMetadata ExternalRefType = "productMetadata"
	// ExternalRefTypePurchaseOrder A reference to a purchase order for a package.
	ExternalRefTypePurchaseOrder ExternalRefType = "purchaseOrder"
	// ExternalRefTypeQualityAssessmentReport A reference to a quality assessment for a package.
	ExternalRefTypeQualityAssessmentReport ExternalRefType = "qualityAssessmentReport"
	// ExternalRefTypeReleaseHistory A reference to a published list of releases for a package.
	ExternalRefTypeReleaseHistory ExternalRefType = "releaseHistory"
	// ExternalRefTypeReleaseNotes A reference to the release notes for a package.
	ExternalRefTypeReleaseNotes ExternalRefType = "releaseNotes"
	// ExternalRefTypeRiskAssessment A reference to a risk assessment for a package.
	ExternalRefTypeRiskAssessment ExternalRefType = "riskAssessment"
	// ExternalRefTypeRuntimeAnalysisReport A reference to a runtime analysis report for a package.
	ExternalRefTypeRuntimeAnalysisReport ExternalRefType = "runtimeAnalysisReport"
	// ExternalRefTypeSecureSoftwareAttestation A reference to information assuring that the software is developed using security practices as defined by [NIST SP 800-218 Secure Software Development Framework (SSDF) Version 1.1](https://csrc.nist.gov/pubs/sp/800/218/final) or [CISA Secure Software Development Attestation Form](https://www.cisa.gov/resources-tools/resources/secure-software-development-attestation-form).
	ExternalRefTypeSecureSoftwareAttestation ExternalRefType = "secureSoftwareAttestation"
	// ExternalRefTypeSecurityAdversaryModel A reference to the security adversary model for a package.
	ExternalRefTypeSecurityAdversaryModel ExternalRefType = "securityAdversaryModel"
	// ExternalRefTypeSecurityAdvisory A reference to a published security advisory (where advisory as defined per [ISO 29147:2018](https://www.iso.org/standard/72311.html)) that may affect one or more elements, e.g., vendor advisories or specific NVD entries.
	ExternalRefTypeSecurityAdvisory ExternalRefType = "securityAdvisory"
	// ExternalRefTypeSecurityFix A reference to the patch or source code that fixes a vulnerability.
	ExternalRefTypeSecurityFix ExternalRefType = "securityFix"
	// ExternalRefTypeSecurityOther A reference to related security information of unspecified type.
	ExternalRefTypeSecurityOther ExternalRefType = "securityOther"
	// ExternalRefTypeSecurityPenTestReport A reference to a [penetration test](https://en.wikipedia.org/wiki/Penetration_test) report for a package.
	ExternalRefTypeSecurityPenTestReport ExternalRefType = "securityPenTestReport"
	// ExternalRefTypeSecurityPolicy A reference to instructions for reporting newly discovered security vulnerabilities for a package.
	ExternalRefTypeSecurityPolicy ExternalRefType = "securityPolicy"
	// ExternalRefTypeSecurityThreatModel A reference the [security threat model](https://en.wikipedia.org/wiki/Threat_model) for a package.
	ExternalRefTypeSecurityThreatModel ExternalRefType = "securityThreatModel"
	// ExternalRefTypeSocialMedia A reference to a social media channel for a package.
	ExternalRefTypeSocialMedia ExternalRefType = "socialMedia"
	// ExternalRefTypeSourceArtifact A reference to an artifact containing the sources for a package.
	ExternalRefTypeSourceArtifact ExternalRefType = "sourceArtifact"
	// ExternalRefTypeStaticAnalysisReport A reference to a static analysis report for a package.
	ExternalRefTypeStaticAnalysisReport ExternalRefType = "staticAnalysisReport"
	// ExternalRefTypeSupport A reference to the software support channel or other support information for a package.
	ExternalRefTypeSupport ExternalRefType = "support"
	// ExternalRefTypeVcs A reference to a version control system related to a software artifact.
	ExternalRefTypeVcs ExternalRefType = "vcs"
	// ExternalRefTypeVulnerabilityDisclosureReport A reference to a Vulnerability Disclosure Report (VDR) which provides the software supplier's analysis and findings describing the impact (or lack of impact) that reported vulnerabilities have on packages or products in the supplier's SBOM as defined in [NIST SP 800-161 Cybersecurity Supply Chain Risk Management Practices for Systems and Organizations](https://csrc.nist.gov/pubs/sp/800/161/r1/final).
	ExternalRefTypeVulnerabilityDisclosureReport ExternalRefType = "vulnerabilityDisclosureReport"
	// ExternalRefTypeVulnerabilityExploitabilityAssessment A reference to a Vulnerability Exploitability eXchange (VEX) statement which provides information on whether a product is impacted by a specific vulnerability in an included package and, if affected, whether there are actions recommended to remediate. See also [NTIA VEX one-page summary](https://ntia.gov/files/ntia/publications/vex_one-page_summary.pdf).
	ExternalRefTypeVulnerabilityExploitabilityAssessment ExternalRefType = "vulnerabilityExploitabilityAssessment"
)

// String returns the string representation of ExternalRefType.
func (v ExternalRefType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid ExternalRefType.
func (v ExternalRefType) IsValid() bool {
	switch v {
	case ExternalRefTypeAltDownloadLocation, ExternalRefTypeAltWebPage, ExternalRefTypeBinaryArtifact, ExternalRefTypeBower, ExternalRefTypeBuildMeta, ExternalRefTypeBuildSystem, ExternalRefTypeCertificationReport, ExternalRefTypeChat, ExternalRefTypeComponentAnalysisReport, ExternalRefTypeCwe, ExternalRefTypeDocumentation, ExternalRefTypeDynamicAnalysisReport, ExternalRefTypeEolNotice, ExternalRefTypeExportControlAssessment, ExternalRefTypeFunding, ExternalRefTypeIssueTracker, ExternalRefTypeLicense, ExternalRefTypeMailingList, ExternalRefTypeMavenCentral, ExternalRefTypeMetrics, ExternalRefTypeNpm, ExternalRefTypeNuget, ExternalRefTypeOther, ExternalRefTypePrivacyAssessment, ExternalRefTypeProductMetadata, ExternalRefTypePurchaseOrder, ExternalRefTypeQualityAssessmentReport, ExternalRefTypeReleaseHistory, ExternalRefTypeReleaseNotes, ExternalRefTypeRiskAssessment, ExternalRefTypeRuntimeAnalysisReport, ExternalRefTypeSecureSoftwareAttestation, ExternalRefTypeSecurityAdversaryModel, ExternalRefTypeSecurityAdvisory, ExternalRefTypeSecurityFix, ExternalRefTypeSecurityOther, ExternalRefTypeSecurityPenTestReport, ExternalRefTypeSecurityPolicy, ExternalRefTypeSecurityThreatModel, ExternalRefTypeSocialMedia, ExternalRefTypeSourceArtifact, ExternalRefTypeStaticAnalysisReport, ExternalRefTypeSupport, ExternalRefTypeVcs, ExternalRefTypeVulnerabilityDisclosureReport, ExternalRefTypeVulnerabilityExploitabilityAssessment:
		return true
	default:
		return false
	}
}

// HashAlgorithm A mathematical algorithm that maps data of arbitrary size to a bit string.
type HashAlgorithm string

const (
	// HashAlgorithmAdler32 Adler-32 checksum is part of the widely used zlib compression library as defined in [RFC 1950](https://datatracker.ietf.org/doc/rfc1950/) Section 2.3.
	HashAlgorithmAdler32 HashAlgorithm = "adler32"
	// HashAlgorithmBlake2b256 BLAKE2b algorithm with a digest size of 256, as defined in [RFC 7693](https://datatracker.ietf.org/doc/rfc7693/) Section 4.
	HashAlgorithmBlake2b256 HashAlgorithm = "blake2b256"
	// HashAlgorithmBlake2b384 BLAKE2b algorithm with a digest size of 384, as defined in [RFC 7693](https://datatracker.ietf.org/doc/rfc7693/) Section 4.
	HashAlgorithmBlake2b384 HashAlgorithm = "blake2b384"
	// HashAlgorithmBlake2b512 BLAKE2b algorithm with a digest size of 512, as defined in [RFC 7693](https://datatracker.ietf.org/doc/rfc7693/) Section 4.
	HashAlgorithmBlake2b512 HashAlgorithm = "blake2b512"
	// HashAlgorithmBlake3 [BLAKE3](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf)
	HashAlgorithmBlake3 HashAlgorithm = "blake3"
	// HashAlgorithmCrystalsDilithium [Dilithium](https://pq-crystals.org/dilithium/)
	HashAlgorithmCrystalsDilithium HashAlgorithm = "crystalsDilithium"
	// HashAlgorithmCrystalsKyber [Kyber](https://pq-crystals.org/kyber/)
	HashAlgorithmCrystalsKyber HashAlgorithm = "crystalsKyber"
	// HashAlgorithmFalcon [FALCON](https://falcon-sign.info/falcon.pdf)
	HashAlgorithmFalcon HashAlgorithm = "falcon"
	// HashAlgorithmMd2 MD2 message-digest algorithm, as defined in [RFC 1319](https://datatracker.ietf.org/doc/rfc1319/).
	HashAlgorithmMd2 HashAlgorithm = "md2"
	// HashAlgorithmMd4 MD4 message-digest algorithm, as defined in [RFC 1186](https://datatracker.ietf.org/doc/rfc1186/).
	HashAlgorithmMd4 HashAlgorithm = "md4"
	// HashAlgorithmMd5 MD5 message-digest algorithm, as defined in [RFC 1321](https://datatracker.ietf.org/doc/rfc1321/).
	HashAlgorithmMd5 HashAlgorithm = "md5"
	// HashAlgorithmMd6 [MD6 hash function](https://people.csail.mit.edu/rivest/pubs/RABCx08.pdf)
	HashAlgorithmMd6 HashAlgorithm = "md6"
	// HashAlgorithmOther any hashing algorithm that does not exist in this list of entries
	HashAlgorithmOther HashAlgorithm = "other"
	// HashAlgorithmSha1 SHA-1, a secure hashing algorithm, as defined in [RFC 3174](https://datatracker.ietf.org/doc/rfc3174/).
	HashAlgorithmSha1 HashAlgorithm = "sha1"
	// HashAlgorithmSha224 SHA-2 with a digest length of 224, as defined in [RFC 3874](https://datatracker.ietf.org/doc/rfc3874/).
	HashAlgorithmSha224 HashAlgorithm = "sha224"
	// HashAlgorithmSha256 SHA-2 with a digest length of 256, as defined in [RFC 6234](https://datatracker.ietf.org/doc/rfc6234/).
	HashAlgorithmSha256 HashAlgorithm = "sha256"
	// HashAlgorithmSha384 SHA-2 with a digest length of 384, as defined in [RFC 6234](https://datatracker.ietf.org/doc/rfc6234/).
	HashAlgorithmSha384 HashAlgorithm = "sha384"
	// HashAlgorithmSha3224 SHA-3 with a digest length of 224, as defined in [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final).
	HashAlgorithmSha3224 HashAlgorithm = "sha3_224"
	// HashAlgorithmSha3256 SHA-3 with a digest length of 256, as defined in [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final).
	HashAlgorithmSha3256 HashAlgorithm = "sha3_256"
	// HashAlgorithmSha3384 SHA-3 with a digest length of 384, as defined in [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final).
	HashAlgorithmSha3384 HashAlgorithm = "sha3_384"
	// HashAlgorithmSha3512 SHA-3 with a digest length of 512, as defined in [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final).
	HashAlgorithmSha3512 HashAlgorithm = "sha3_512"
	// HashAlgorithmSha512 SHA-2 with a digest length of 512, as defined in [RFC 6234](https://datatracker.ietf.org/doc/rfc6234/).
	HashAlgorithmSha512 HashAlgorithm = "sha512"
)

// String returns the string representation of HashAlgorithm.
func (v HashAlgorithm) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid HashAlgorithm.
func (v HashAlgorithm) IsValid() bool {
	switch v {
	case HashAlgorithmAdler32, HashAlgorithmBlake2b256, HashAlgorithmBlake2b384, HashAlgorithmBlake2b512, HashAlgorithmBlake3, HashAlgorithmCrystalsDilithium, HashAlgorithmCrystalsKyber, HashAlgorithmFalcon, HashAlgorithmMd2, HashAlgorithmMd4, HashAlgorithmMd5, HashAlgorithmMd6, HashAlgorithmOther, HashAlgorithmSha1, HashAlgorithmSha224, HashAlgorithmSha256, HashAlgorithmSha384, HashAlgorithmSha3224, HashAlgorithmSha3256, HashAlgorithmSha3384, HashAlgorithmSha3512, HashAlgorithmSha512:
		return true
	default:
		return false
	}
}

// LifecycleScopeType Provide an enumerated set of lifecycle phases that can provide context to relationships.
type LifecycleScopeType string

const (
	// LifecycleScopeTypeBuild A relationship has specific context implications during an element's build phase, during development.
	LifecycleScopeTypeBuild LifecycleScopeType = "build"
	// LifecycleScopeTypeDesign A relationship has specific context implications during an element's design.
	LifecycleScopeTypeDesign LifecycleScopeType = "design"
	// LifecycleScopeTypeDevelopment A relationship has specific context implications during development phase of an element.
	LifecycleScopeTypeDevelopment LifecycleScopeType = "development"
	// LifecycleScopeTypeOther A relationship has other specific context information necessary to capture that the above set of enumerations does not handle.
	LifecycleScopeTypeOther LifecycleScopeType = "other"
	// LifecycleScopeTypeRuntime A relationship has specific context implications during the execution phase of an element.
	LifecycleScopeTypeRuntime LifecycleScopeType = "runtime"
	// LifecycleScopeTypeTest A relationship has specific context implications during an element's testing phase, during development.
	LifecycleScopeTypeTest LifecycleScopeType = "test"
)

// String returns the string representation of LifecycleScopeType.
func (v LifecycleScopeType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid LifecycleScopeType.
func (v LifecycleScopeType) IsValid() bool {
	switch v {
	case LifecycleScopeTypeBuild, LifecycleScopeTypeDesign, LifecycleScopeTypeDevelopment, LifecycleScopeTypeOther, LifecycleScopeTypeRuntime, LifecycleScopeTypeTest:
		return true
	default:
		return false
	}
}

// PresenceType Categories of presence or absence.
type PresenceType string

const (
	// PresenceTypeNo Indicates absence of the field.
	PresenceTypeNo PresenceType = "no"
	// PresenceTypeNoAssertion Makes no assertion about the field.
	PresenceTypeNoAssertion PresenceType = "noAssertion"
	// PresenceTypeYes Indicates presence of the field.
	PresenceTypeYes PresenceType = "yes"
)

// String returns the string representation of PresenceType.
func (v PresenceType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid PresenceType.
func (v PresenceType) IsValid() bool {
	switch v {
	case PresenceTypeNo, PresenceTypeNoAssertion, PresenceTypeYes:
		return true
	default:
		return false
	}
}

// ProfileIdentifierType Enumeration of the valid profiles.
type ProfileIdentifierType string

const (
	// ProfileIdentifierTypeAi the element follows the AI profile specification
	ProfileIdentifierTypeAi ProfileIdentifierType = "ai"
	// ProfileIdentifierTypeBuild the element follows the Build profile specification
	ProfileIdentifierTypeBuild ProfileIdentifierType = "build"
	// ProfileIdentifierTypeCore the element follows the Core profile specification
	ProfileIdentifierTypeCore ProfileIdentifierType = "core"
	// ProfileIdentifierTypeDataset the element follows the Dataset profile specification
	ProfileIdentifierTypeDataset ProfileIdentifierType = "dataset"
	// ProfileIdentifierTypeExpandedLicensing the element follows the ExpandedLicensing profile specification
	ProfileIdentifierTypeExpandedLicensing ProfileIdentifierType = "expandedLicensing"
	// ProfileIdentifierTypeExtension the element follows the Extension profile specification
	ProfileIdentifierTypeExtension ProfileIdentifierType = "extension"
	// ProfileIdentifierTypeLite the element follows the Lite profile specification
	ProfileIdentifierTypeLite ProfileIdentifierType = "lite"
	// ProfileIdentifierTypeSecurity the element follows the Security profile specification
	ProfileIdentifierTypeSecurity ProfileIdentifierType = "security"
	// ProfileIdentifierTypeSimpleLicensing the element follows the SimpleLicensing profile specification
	ProfileIdentifierTypeSimpleLicensing ProfileIdentifierType = "simpleLicensing"
	// ProfileIdentifierTypeSoftware the element follows the Software profile specification
	ProfileIdentifierTypeSoftware ProfileIdentifierType = "software"
)

// String returns the string representation of ProfileIdentifierType.
func (v ProfileIdentifierType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid ProfileIdentifierType.
func (v ProfileIdentifierType) IsValid() bool {
	switch v {
	case ProfileIdentifierTypeAi, ProfileIdentifierTypeBuild, ProfileIdentifierTypeCore, ProfileIdentifierTypeDataset, ProfileIdentifierTypeExpandedLicensing, ProfileIdentifierTypeExtension, ProfileIdentifierTypeLite, ProfileIdentifierTypeSecurity, ProfileIdentifierTypeSimpleLicensing, ProfileIdentifierTypeSoftware:
		return true
	default:
		return false
	}
}

// RelationshipCompleteness Indicates whether a relationship is known to be complete, incomplete, or if no assertion is made with respect to relationship completeness.
type RelationshipCompleteness string

const (
	// RelationshipCompletenessComplete The relationship is known to be exhaustive.
	RelationshipCompletenessComplete RelationshipCompleteness = "complete"
	// RelationshipCompletenessIncomplete The relationship is known not to be exhaustive.
	RelationshipCompletenessIncomplete RelationshipCompleteness = "incomplete"
	// RelationshipCompletenessNoAssertion No assertion can be made about the completeness of the relationship.
	RelationshipCompletenessNoAssertion RelationshipCompleteness = "noAssertion"
)

// String returns the string representation of RelationshipCompleteness.
func (v RelationshipCompleteness) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid RelationshipCompleteness.
func (v RelationshipCompleteness) IsValid() bool {
	switch v {
	case RelationshipCompletenessComplete, RelationshipCompletenessIncomplete, RelationshipCompletenessNoAssertion:
		return true
	default:
		return false
	}
}

// RelationshipType Information about the relationship between two Elements.
type RelationshipType string

const (
	// RelationshipTypeAffects The `from` Vulnerability affects each `to` Element. The use of the `affects` type is constrained to `VexAffectedVulnAssessmentRelationship` classed relationships.
	RelationshipTypeAffects RelationshipType = "affects"
	// RelationshipTypeAmendedBy The `from` Element is amended by each `to` Element.
	RelationshipTypeAmendedBy RelationshipType = "amendedBy"
	// RelationshipTypeAncestorOf The `from` Element is an ancestor of each `to` Element.
	RelationshipTypeAncestorOf RelationshipType = "ancestorOf"
	// RelationshipTypeAvailableFrom The `from` Element is available from the additional supplier described by each `to` Element.
	RelationshipTypeAvailableFrom RelationshipType = "availableFrom"
	// RelationshipTypeConfigures The `from` Element is a configuration applied to each `to` Element, during a LifecycleScopeType period.
	RelationshipTypeConfigures RelationshipType = "configures"
	// RelationshipTypeContains The `from` Element contains each `to` Element.
	RelationshipTypeContains RelationshipType = "contains"
	// RelationshipTypeCoordinatedBy The `from` Vulnerability is coordinatedBy the `to` Agent(s) (vendor, researcher, or consumer agent).
	RelationshipTypeCoordinatedBy RelationshipType = "coordinatedBy"
	// RelationshipTypeCopiedTo The `from` Element has been copied to each `to` Element.
	RelationshipTypeCopiedTo RelationshipType = "copiedTo"
	// RelationshipTypeDelegatedTo The `from` Agent is delegating an action to the Agent of the `to` Relationship (which must be of type invokedBy), during a LifecycleScopeType (e.g. the `to` invokedBy Relationship is being done on behalf of `from`).
	RelationshipTypeDelegatedTo RelationshipType = "delegatedTo"
	// RelationshipTypeDependsOn The `from` Element depends on each `to` Element, during a LifecycleScopeType period.
	RelationshipTypeDependsOn RelationshipType = "dependsOn"
	// RelationshipTypeDescendantOf The `from` Element is a descendant of each `to` Element.
	RelationshipTypeDescendantOf RelationshipType = "descendantOf"
	// RelationshipTypeDescribes The `from` Element describes each `to` Element. To denote the root(s) of a tree of elements in a collection, the rootElement property should be used.
	RelationshipTypeDescribes RelationshipType = "describes"
	// RelationshipTypeDoesNotAffect The `from` Vulnerability has no impact on each `to` Element. The use of the `doesNotAffect` is constrained to `VexNotAffectedVulnAssessmentRelationship` classed relationships.
	RelationshipTypeDoesNotAffect RelationshipType = "doesNotAffect"
	// RelationshipTypeExpandsTo The `from` archive expands out as an artifact described by each `to` Element.
	RelationshipTypeExpandsTo RelationshipType = "expandsTo"
	// RelationshipTypeExploitCreatedBy The `from` Vulnerability has had an exploit created against it by each `to` Agent.
	RelationshipTypeExploitCreatedBy RelationshipType = "exploitCreatedBy"
	// RelationshipTypeFixedBy Designates a `from` Vulnerability has been fixed by the `to` Agent(s).
	RelationshipTypeFixedBy RelationshipType = "fixedBy"
	// RelationshipTypeFixedIn A `from` Vulnerability has been fixed in each `to` Element. The use of the `fixedIn` type is constrained to `VexFixedVulnAssessmentRelationship` classed relationships.
	RelationshipTypeFixedIn RelationshipType = "fixedIn"
	// RelationshipTypeFoundBy Designates a `from` Vulnerability was originally discovered by the `to` Agent(s).
	RelationshipTypeFoundBy RelationshipType = "foundBy"
	// RelationshipTypeGenerates The `from` Element generates each `to` Element.
	RelationshipTypeGenerates RelationshipType = "generates"
	// RelationshipTypeHasAddedFile Every `to` Element is a file added to the `from` Element (`from` hasAddedFile `to`).
	RelationshipTypeHasAddedFile RelationshipType = "hasAddedFile"
	// RelationshipTypeHasAssessmentFor Relates a `from` Vulnerability and each `to` Element with a security assessment. To be used with `VulnAssessmentRelationship` types.
	RelationshipTypeHasAssessmentFor RelationshipType = "hasAssessmentFor"
	// RelationshipTypeHasAssociatedVulnerability Used to associate a `from` Artifact with each `to` Vulnerability.
	RelationshipTypeHasAssociatedVulnerability RelationshipType = "hasAssociatedVulnerability"
	// RelationshipTypeHasConcludedLicense The `from` SoftwareArtifact is concluded by the SPDX data creator to be governed by each `to` license.
	RelationshipTypeHasConcludedLicense RelationshipType = "hasConcludedLicense"
	// RelationshipTypeHasDataFile The `from` Element treats each `to` Element as a data file. A data file is an artifact that stores data required or optional for the `from` Element's functionality. A data file can be a database file, an index file, a log file, an AI model file, a calibration data file, a temporary file, a backup file, and more. For AI training dataset, test dataset, test artifact, configuration data, build input data, and build output data, please consider using the more specific relationship types: `trainedOn`, `testedOn`, `hasTest`, `configures`, `hasInput`, and `hasOutput`, respectively. This relationship does not imply dependency.
	RelationshipTypeHasDataFile RelationshipType = "hasDataFile"
	// RelationshipTypeHasDeclaredLicense The `from` SoftwareArtifact was discovered to actually contain each `to` license, for example as detected by use of automated tooling.
	RelationshipTypeHasDeclaredLicense RelationshipType = "hasDeclaredLicense"
	// RelationshipTypeHasDeletedFile Every `to` Element is a file deleted from the `from` Element (`from` hasDeletedFile `to`).
	RelationshipTypeHasDeletedFile RelationshipType = "hasDeletedFile"
	// RelationshipTypeHasDependencyManifest The `from` Element has manifest files that contain dependency information in each `to` Element.
	RelationshipTypeHasDependencyManifest RelationshipType = "hasDependencyManifest"
	// RelationshipTypeHasDistributionArtifact The `from` Element is distributed as an artifact in each `to` Element (e.g. an RPM or archive file).
	RelationshipTypeHasDistributionArtifact RelationshipType = "hasDistributionArtifact"
	// RelationshipTypeHasDocumentation The `from` Element is documented by each `to` Element.
	RelationshipTypeHasDocumentation RelationshipType = "hasDocumentation"
	// RelationshipTypeHasDynamicLink The `from` Element dynamically links in each `to` Element, during a LifecycleScopeType period.
	RelationshipTypeHasDynamicLink RelationshipType = "hasDynamicLink"
	// RelationshipTypeHasEvidence Every `to` Element is considered as evidence for the `from` Element (`from` hasEvidence `to`).
	RelationshipTypeHasEvidence RelationshipType = "hasEvidence"
	// RelationshipTypeHasExample Every `to` Element is an example for the `from` Element (`from` hasExample `to`).
	RelationshipTypeHasExample RelationshipType = "hasExample"
	// RelationshipTypeHasHost The `from` Build was run on the `to` Element during a LifecycleScopeType period (e.g. the host that the build runs on).
	RelationshipTypeHasHost RelationshipType = "hasHost"
	// RelationshipTypeHasInput The `from` Build has each `to` Element as an input, during a LifecycleScopeType period.
	RelationshipTypeHasInput RelationshipType = "hasInput"
	// RelationshipTypeHasMetadata Every `to` Element is metadata about the `from` Element (`from` hasMetadata `to`).
	RelationshipTypeHasMetadata RelationshipType = "hasMetadata"
	// RelationshipTypeHasOptionalComponent Every `to` Element is an optional component of the `from` Element (`from` hasOptionalComponent `to`).
	RelationshipTypeHasOptionalComponent RelationshipType = "hasOptionalComponent"
	// RelationshipTypeHasOptionalDependency The `from` Element optionally depends on each `to` Element, during a LifecycleScopeType period.
	RelationshipTypeHasOptionalDependency RelationshipType = "hasOptionalDependency"
	// RelationshipTypeHasOutput The `from` Build element generates each `to` Element as an output, during a LifecycleScopeType period.
	RelationshipTypeHasOutput RelationshipType = "hasOutput"
	// RelationshipTypeHasPrerequisite The `from` Element has a prerequisite on each `to` Element, during a LifecycleScopeType period.
	RelationshipTypeHasPrerequisite RelationshipType = "hasPrerequisite"
	// RelationshipTypeHasProvidedDependency The `from` Element has a dependency on each `to` Element, dependency is not in the distributed artifact, but assumed to be provided, during a LifecycleScopeType period.
	RelationshipTypeHasProvidedDependency RelationshipType = "hasProvidedDependency"
	// RelationshipTypeHasRequirement The `from` Element has a requirement on each `to` Element, during a LifecycleScopeType period.
	RelationshipTypeHasRequirement RelationshipType = "hasRequirement"
	// RelationshipTypeHasSpecification Every `to` Element is a specification for the `from` Element (`from` hasSpecification `to`), during a LifecycleScopeType period.
	RelationshipTypeHasSpecification RelationshipType = "hasSpecification"
	// RelationshipTypeHasStaticLink The `from` Element statically links in each `to` Element, during a LifecycleScopeType period.
	RelationshipTypeHasStaticLink RelationshipType = "hasStaticLink"
	// RelationshipTypeHasTest Every `to` Element is a test artifact for the `from` Element (`from` hasTest `to`), during a LifecycleScopeType period.
	RelationshipTypeHasTest RelationshipType = "hasTest"
	// RelationshipTypeHasTestCase Every `to` Element is a test case for the `from` Element (`from` hasTestCase `to`).
	RelationshipTypeHasTestCase RelationshipType = "hasTestCase"
	// RelationshipTypeHasVariant Every `to` Element is a variant the `from` Element (`from` hasVariant `to`).
	RelationshipTypeHasVariant RelationshipType = "hasVariant"
	// RelationshipTypeInvokedBy The `from` Element was invoked by the `to` Agent, during a LifecycleScopeType period (for example, a Build element that describes a build step).
	RelationshipTypeInvokedBy RelationshipType = "invokedBy"
	// RelationshipTypeModifiedBy The `from` Element is modified by each `to` Element.
	RelationshipTypeModifiedBy RelationshipType = "modifiedBy"
	// RelationshipTypeOther Every `to` Element is related to the `from` Element where the relationship type is not described by any of the SPDX relationship types (this relationship is directionless).
	RelationshipTypeOther RelationshipType = "other"
	// RelationshipTypePackagedBy Every `to` Element is a packaged instance of the `from` Element (`from` packagedBy `to`).
	RelationshipTypePackagedBy RelationshipType = "packagedBy"
	// RelationshipTypePatchedBy Every `to` Element is a patch for the `from` Element (`from` patchedBy `to`).
	RelationshipTypePatchedBy RelationshipType = "patchedBy"
	// RelationshipTypePublishedBy Designates a `from` Vulnerability was made available for public use or reference by each `to` Agent.
	RelationshipTypePublishedBy RelationshipType = "publishedBy"
	// RelationshipTypeReportedBy Designates a `from` Vulnerability was first reported to a project, vendor, or tracking database for formal identification by each `to` Agent.
	RelationshipTypeReportedBy RelationshipType = "reportedBy"
	// RelationshipTypeRepublishedBy Designates a `from` Vulnerability's details were tracked, aggregated, and/or enriched to improve context (i.e. NVD) by each `to` Agent.
	RelationshipTypeRepublishedBy RelationshipType = "republishedBy"
	// RelationshipTypeSerializedInArtifact The `from` SpdxDocument can be found in a serialized form in each `to` Artifact.
	RelationshipTypeSerializedInArtifact RelationshipType = "serializedInArtifact"
	// RelationshipTypeTestedOn The `from` Element has been tested on the `to` Element(s).
	RelationshipTypeTestedOn RelationshipType = "testedOn"
	// RelationshipTypeTrainedOn The `from` Element has been trained on the `to` Element(s).
	RelationshipTypeTrainedOn RelationshipType = "trainedOn"
	// RelationshipTypeUnderInvestigationFor The `from` Vulnerability impact is being investigated for each `to` Element. The use of the `underInvestigationFor` type is constrained to `VexUnderInvestigationVulnAssessmentRelationship` classed relationships.
	RelationshipTypeUnderInvestigationFor RelationshipType = "underInvestigationFor"
	// RelationshipTypeUsesTool The `from` Element uses each `to` Element as a tool, during a LifecycleScopeType period.
	RelationshipTypeUsesTool RelationshipType = "usesTool"
)

// String returns the string representation of RelationshipType.
func (v RelationshipType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid RelationshipType.
func (v RelationshipType) IsValid() bool {
	switch v {
	case RelationshipTypeAffects, RelationshipTypeAmendedBy, RelationshipTypeAncestorOf, RelationshipTypeAvailableFrom, RelationshipTypeConfigures, RelationshipTypeContains, RelationshipTypeCoordinatedBy, RelationshipTypeCopiedTo, RelationshipTypeDelegatedTo, RelationshipTypeDependsOn, RelationshipTypeDescendantOf, RelationshipTypeDescribes, RelationshipTypeDoesNotAffect, RelationshipTypeExpandsTo, RelationshipTypeExploitCreatedBy, RelationshipTypeFixedBy, RelationshipTypeFixedIn, RelationshipTypeFoundBy, RelationshipTypeGenerates, RelationshipTypeHasAddedFile, RelationshipTypeHasAssessmentFor, RelationshipTypeHasAssociatedVulnerability, RelationshipTypeHasConcludedLicense, RelationshipTypeHasDataFile, RelationshipTypeHasDeclaredLicense, RelationshipTypeHasDeletedFile, RelationshipTypeHasDependencyManifest, RelationshipTypeHasDistributionArtifact, RelationshipTypeHasDocumentation, RelationshipTypeHasDynamicLink, RelationshipTypeHasEvidence, RelationshipTypeHasExample, RelationshipTypeHasHost, RelationshipTypeHasInput, RelationshipTypeHasMetadata, RelationshipTypeHasOptionalComponent, RelationshipTypeHasOptionalDependency, RelationshipTypeHasOutput, RelationshipTypeHasPrerequisite, RelationshipTypeHasProvidedDependency, RelationshipTypeHasRequirement, RelationshipTypeHasSpecification, RelationshipTypeHasStaticLink, RelationshipTypeHasTest, RelationshipTypeHasTestCase, RelationshipTypeHasVariant, RelationshipTypeInvokedBy, RelationshipTypeModifiedBy, RelationshipTypeOther, RelationshipTypePackagedBy, RelationshipTypePatchedBy, RelationshipTypePublishedBy, RelationshipTypeReportedBy, RelationshipTypeRepublishedBy, RelationshipTypeSerializedInArtifact, RelationshipTypeTestedOn, RelationshipTypeTrainedOn, RelationshipTypeUnderInvestigationFor, RelationshipTypeUsesTool:
		return true
	default:
		return false
	}
}

// SupportType Indicates the type of support that is associated with an artifact.
type SupportType string

const (
	// SupportTypeDeployed in addition to being supported by the supplier, the software is known to have been deployed and is in use.  For a software as a service provider, this implies the software is now available as a service.
	SupportTypeDeployed SupportType = "deployed"
	// SupportTypeDevelopment the artifact is in active development and is not considered ready for formal support from the supplier.
	SupportTypeDevelopment SupportType = "development"
	// SupportTypeEndOfSupport there is a defined end of support for the artifact from the supplier.  This may also be referred to as end of life. There is a validUntilDate that can be used to signal when support ends for the artifact.
	SupportTypeEndOfSupport SupportType = "endOfSupport"
	// SupportTypeLimitedSupport the artifact has been released, and there is limited support available from the supplier. There is a validUntilDate that can provide additional information about the duration of support.
	SupportTypeLimitedSupport SupportType = "limitedSupport"
	// SupportTypeNoAssertion no assertion about the type of support is made.   This is considered the default if no other support type is used.
	SupportTypeNoAssertion SupportType = "noAssertion"
	// SupportTypeNoSupport there is no support for the artifact from the supplier, consumer assumes any support obligations.
	SupportTypeNoSupport SupportType = "noSupport"
	// SupportTypeSupport the artifact has been released, and is supported from the supplier.   There is a validUntilDate that can provide additional information about the duration of support.
	SupportTypeSupport SupportType = "support"
)

// String returns the string representation of SupportType.
func (v SupportType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid SupportType.
func (v SupportType) IsValid() bool {
	switch v {
	case SupportTypeDeployed, SupportTypeDevelopment, SupportTypeEndOfSupport, SupportTypeLimitedSupport, SupportTypeNoAssertion, SupportTypeNoSupport, SupportTypeSupport:
		return true
	default:
		return false
	}
}

// ConfidentialityLevelType Categories of confidentiality level.
type ConfidentialityLevelType string

const (
	// ConfidentialityLevelTypeAmber Data points in the dataset can be shared only with specific organizations and their clients on a need to know basis.
	ConfidentialityLevelTypeAmber ConfidentialityLevelType = "amber"
	// ConfidentialityLevelTypeClear Dataset may be distributed freely, without restriction.
	ConfidentialityLevelTypeClear ConfidentialityLevelType = "clear"
	// ConfidentialityLevelTypeGreen Dataset can be shared within a community of peers and partners.
	ConfidentialityLevelTypeGreen ConfidentialityLevelType = "green"
	// ConfidentialityLevelTypeRed Data points in the dataset are highly confidential and can only be shared with named recipients.
	ConfidentialityLevelTypeRed ConfidentialityLevelType = "red"
)

// String returns the string representation of ConfidentialityLevelType.
func (v ConfidentialityLevelType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid ConfidentialityLevelType.
func (v ConfidentialityLevelType) IsValid() bool {
	switch v {
	case ConfidentialityLevelTypeAmber, ConfidentialityLevelTypeClear, ConfidentialityLevelTypeGreen, ConfidentialityLevelTypeRed:
		return true
	default:
		return false
	}
}

// DatasetAvailabilityType Availability of dataset.
type DatasetAvailabilityType string

const (
	// DatasetAvailabilityTypeClickthrough the dataset is not publicly available and can only be accessed after affirmatively accepting terms on a clickthrough webpage.
	DatasetAvailabilityTypeClickthrough DatasetAvailabilityType = "clickthrough"
	// DatasetAvailabilityTypeDirectDownload the dataset is publicly available and can be downloaded directly.
	DatasetAvailabilityTypeDirectDownload DatasetAvailabilityType = "directDownload"
	// DatasetAvailabilityTypeQuery the dataset is publicly available, but not all at once, and can only be accessed through queries which return parts of the dataset.
	DatasetAvailabilityTypeQuery DatasetAvailabilityType = "query"
	// DatasetAvailabilityTypeRegistration the dataset is not publicly available and an email registration is required before accessing the dataset, although without an affirmative acceptance of terms.
	DatasetAvailabilityTypeRegistration DatasetAvailabilityType = "registration"
	// DatasetAvailabilityTypeScrapingScript the dataset provider is not making available the underlying data and the dataset must be reassembled, typically using the provided script for scraping the data.
	DatasetAvailabilityTypeScrapingScript DatasetAvailabilityType = "scrapingScript"
)

// String returns the string representation of DatasetAvailabilityType.
func (v DatasetAvailabilityType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid DatasetAvailabilityType.
func (v DatasetAvailabilityType) IsValid() bool {
	switch v {
	case DatasetAvailabilityTypeClickthrough, DatasetAvailabilityTypeDirectDownload, DatasetAvailabilityTypeQuery, DatasetAvailabilityTypeRegistration, DatasetAvailabilityTypeScrapingScript:
		return true
	default:
		return false
	}
}

// DatasetType Enumeration of dataset types.
type DatasetType string

const (
	// DatasetTypeAudio data is audio based, such as a collection of music from the 80s.
	DatasetTypeAudio DatasetType = "audio"
	// DatasetTypeCategorical data that is classified into a discrete number of categories, such as the eye color of a population of people.
	DatasetTypeCategorical DatasetType = "categorical"
	// DatasetTypeGraph data is in the form of a graph where entries are somehow related to each other through edges, such a social network of friends.
	DatasetTypeGraph DatasetType = "graph"
	// DatasetTypeImage data is a collection of images such as pictures of animals.
	DatasetTypeImage DatasetType = "image"
	// DatasetTypeNoAssertion data type is not known.
	DatasetTypeNoAssertion DatasetType = "noAssertion"
	// DatasetTypeNumeric data consists only of numeric entries.
	DatasetTypeNumeric DatasetType = "numeric"
	// DatasetTypeOther data is of a type not included in this list.
	DatasetTypeOther DatasetType = "other"
	// DatasetTypeSensor data is recorded from a physical sensor, such as a thermometer reading or biometric device.
	DatasetTypeSensor DatasetType = "sensor"
	// DatasetTypeStructured data is stored in tabular format or retrieved from a relational database.
	DatasetTypeStructured DatasetType = "structured"
	// DatasetTypeSyntactic data describes the syntax or semantics of a language or text, such as a parse tree used for natural language processing.
	DatasetTypeSyntactic DatasetType = "syntactic"
	// DatasetTypeText data consists of unstructured text, such as a book, Wikipedia article (without images), or transcript.
	DatasetTypeText DatasetType = "text"
	// DatasetTypeTimeseries data is recorded in an ordered sequence of timestamped entries, such as the price of a stock over the course of a day.
	DatasetTypeTimeseries DatasetType = "timeseries"
	// DatasetTypeTimestamp data is recorded with a timestamp for each entry, but not necessarily ordered or at specific intervals, such as when a taxi ride starts and ends.
	DatasetTypeTimestamp DatasetType = "timestamp"
	// DatasetTypeVideo data is video based, such as a collection of movie clips featuring Tom Hanks.
	DatasetTypeVideo DatasetType = "video"
)

// String returns the string representation of DatasetType.
func (v DatasetType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid DatasetType.
func (v DatasetType) IsValid() bool {
	switch v {
	case DatasetTypeAudio, DatasetTypeCategorical, DatasetTypeGraph, DatasetTypeImage, DatasetTypeNoAssertion, DatasetTypeNumeric, DatasetTypeOther, DatasetTypeSensor, DatasetTypeStructured, DatasetTypeSyntactic, DatasetTypeText, DatasetTypeTimeseries, DatasetTypeTimestamp, DatasetTypeVideo:
		return true
	default:
		return false
	}
}

// CvssSeverityType Specifies the CVSS base, temporal, threat, or environmental severity type.
type CvssSeverityType string

const (
	// CvssSeverityTypeCritical When a CVSS score is between 9.0 - 10.0
	CvssSeverityTypeCritical CvssSeverityType = "critical"
	// CvssSeverityTypeHigh When a CVSS score is between 7.0 - 8.9
	CvssSeverityTypeHigh CvssSeverityType = "high"
	// CvssSeverityTypeLow When a CVSS score is between 0.1 - 3.9
	CvssSeverityTypeLow CvssSeverityType = "low"
	// CvssSeverityTypeMedium When a CVSS score is between 4.0 - 6.9
	CvssSeverityTypeMedium CvssSeverityType = "medium"
	// CvssSeverityTypeNone When a CVSS score is 0.0
	CvssSeverityTypeNone CvssSeverityType = "none"
)

// String returns the string representation of CvssSeverityType.
func (v CvssSeverityType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid CvssSeverityType.
func (v CvssSeverityType) IsValid() bool {
	switch v {
	case CvssSeverityTypeCritical, CvssSeverityTypeHigh, CvssSeverityTypeLow, CvssSeverityTypeMedium, CvssSeverityTypeNone:
		return true
	default:
		return false
	}
}

// ExploitCatalogType Specifies the exploit catalog type.
type ExploitCatalogType string

const (
	// ExploitCatalogTypeKev CISA's Known Exploited Vulnerability (KEV) Catalog
	ExploitCatalogTypeKev ExploitCatalogType = "kev"
	// ExploitCatalogTypeOther Other exploit catalogs
	ExploitCatalogTypeOther ExploitCatalogType = "other"
)

// String returns the string representation of ExploitCatalogType.
func (v ExploitCatalogType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid ExploitCatalogType.
func (v ExploitCatalogType) IsValid() bool {
	switch v {
	case ExploitCatalogTypeKev, ExploitCatalogTypeOther:
		return true
	default:
		return false
	}
}

// SsvcDecisionType Specifies the SSVC decision type.
type SsvcDecisionType string

const (
	// SsvcDecisionTypeAct The vulnerability requires attention from the organization's internal, supervisory-level and leadership-level individuals. Necessary actions include requesting assistance or information about the vulnerability, as well as publishing a notification either internally and/or externally. Typically, internal groups would meet to determine the overall response and then execute agreed upon actions. CISA recommends remediating Act vulnerabilities as soon as possible.
	SsvcDecisionTypeAct SsvcDecisionType = "act"
	// SsvcDecisionTypeAttend The vulnerability requires attention from the organization's internal, supervisory-level individuals. Necessary actions include requesting assistance or information about the vulnerability, and may involve publishing a notification either internally and/or externally. CISA recommends remediating Attend vulnerabilities sooner than standard update timelines.
	SsvcDecisionTypeAttend SsvcDecisionType = "attend"
	// SsvcDecisionTypeTrack The vulnerability does not require action at this time. The organization would continue to track the vulnerability and reassess it if new information becomes available. CISA recommends remediating Track vulnerabilities within standard update timelines.
	SsvcDecisionTypeTrack SsvcDecisionType = "track"
	// SsvcDecisionTypeTrackStar ("Track\*" in the SSVC spec) The vulnerability contains specific characteristics that may require closer monitoring for changes. CISA recommends remediating Track\* vulnerabilities within standard update timelines.
	SsvcDecisionTypeTrackStar SsvcDecisionType = "trackStar"
)

// String returns the string representation of SsvcDecisionType.
func (v SsvcDecisionType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid SsvcDecisionType.
func (v SsvcDecisionType) IsValid() bool {
	switch v {
	case SsvcDecisionTypeAct, SsvcDecisionTypeAttend, SsvcDecisionTypeTrack, SsvcDecisionTypeTrackStar:
		return true
	default:
		return false
	}
}

// VexJustificationType Specifies the VEX justification type.
type VexJustificationType string

const (
	// VexJustificationTypeComponentNotPresent The software is not affected because the vulnerable component is not in the product.
	VexJustificationTypeComponentNotPresent VexJustificationType = "componentNotPresent"
	// VexJustificationTypeInlineMitigationsAlreadyExist Built-in inline controls or mitigations prevent an adversary from leveraging the vulnerability.
	VexJustificationTypeInlineMitigationsAlreadyExist VexJustificationType = "inlineMitigationsAlreadyExist"
	// VexJustificationTypeVulnerableCodeCannotBeControlledByAdversary The vulnerable component is present, and the component contains the vulnerable code. However, vulnerable code is used in such a way that an attacker cannot mount any anticipated attack.
	VexJustificationTypeVulnerableCodeCannotBeControlledByAdversary VexJustificationType = "vulnerableCodeCannotBeControlledByAdversary"
	// VexJustificationTypeVulnerableCodeNotInExecutePath The affected code is not reachable through the execution of the code, including non-anticipated states of the product.
	VexJustificationTypeVulnerableCodeNotInExecutePath VexJustificationType = "vulnerableCodeNotInExecutePath"
	// VexJustificationTypeVulnerableCodeNotPresent The product is not affected because the code underlying the vulnerability is not present in the product.
	VexJustificationTypeVulnerableCodeNotPresent VexJustificationType = "vulnerableCodeNotPresent"
)

// String returns the string representation of VexJustificationType.
func (v VexJustificationType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid VexJustificationType.
func (v VexJustificationType) IsValid() bool {
	switch v {
	case VexJustificationTypeComponentNotPresent, VexJustificationTypeInlineMitigationsAlreadyExist, VexJustificationTypeVulnerableCodeCannotBeControlledByAdversary, VexJustificationTypeVulnerableCodeNotInExecutePath, VexJustificationTypeVulnerableCodeNotPresent:
		return true
	default:
		return false
	}
}

// ContentIdentifierType Specifies the type of a content identifier.
type ContentIdentifierType string

const (
	// ContentIdentifierTypeGitoid [Gitoid](https://www.iana.org/assignments/uri-schemes/prov/gitoid), stands for [Git Object ID](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects). A gitoid of type blob is a unique hash of a binary artifact. A gitoid may represent either an [Artifact Identifier](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-identifier-types) for the software artifact or an [Input Manifest Identifier](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#input-manifest-identifier) for the software artifact's associated [Artifact Input Manifest](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-input-manifest); this ambiguity exists because the Artifact Input Manifest is itself an artifact, and the gitoid of that artifact is its valid identifier. Gitoids calculated on software artifacts (Snippet, File, or Package Elements) should be recorded in the SPDX 3.0 SoftwareArtifact's contentIdentifier property. Gitoids calculated on the Artifact Input Manifest (Input Manifest Identifier) should be recorded in the SPDX 3.0 Element's externalIdentifier property. See [OmniBOR Specification](https://github.com/omnibor/spec/), a minimalistic specification for describing software [Artifact Dependency Graphs](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-dependency-graph-adg).
	ContentIdentifierTypeGitoid ContentIdentifierType = "gitoid"
	// ContentIdentifierTypeSwhid SoftWare Hash IDentifier, a persistent intrinsic identifier for digital artifacts, such as files, trees (also known as directories or folders), commits, and other objects typically found in version control systems. The format of the identifiers is defined in the [SWHID specification](https://www.swhid.org/specification/v1.1/4.Syntax) (ISO/IEC DIS 18670). They typically look like `swh:1:cnt:94a9ed024d3859793618152ea559a168bbcbb5e2`.
	ContentIdentifierTypeSwhid ContentIdentifierType = "swhid"
)

// String returns the string representation of ContentIdentifierType.
func (v ContentIdentifierType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid ContentIdentifierType.
func (v ContentIdentifierType) IsValid() bool {
	switch v {
	case ContentIdentifierTypeGitoid, ContentIdentifierTypeSwhid:
		return true
	default:
		return false
	}
}

// FileKindType Enumeration of the different kinds of SPDX file.
type FileKindType string

const (
	// FileKindTypeDirectory The file represents a directory and all content stored in that directory.
	FileKindTypeDirectory FileKindType = "directory"
	// FileKindTypeFile The file represents a single file (default).
	FileKindTypeFile FileKindType = "file"
)

// String returns the string representation of FileKindType.
func (v FileKindType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid FileKindType.
func (v FileKindType) IsValid() bool {
	switch v {
	case FileKindTypeDirectory, FileKindTypeFile:
		return true
	default:
		return false
	}
}

// SbomType Provides a set of values to be used to describe the common types of SBOMs that tools may create.
type SbomType string

const (
	// SbomTypeAnalyzed SBOM generated through analysis of artifacts (e.g., executables, packages, containers, and virtual machine images) after its build. Such analysis generally requires a variety of heuristics. In some contexts, this may also be referred to as a "3rd party" SBOM.
	SbomTypeAnalyzed SbomType = "analyzed"
	// SbomTypeBuild SBOM generated as part of the process of building the software to create a releasable artifact (e.g., executable or package) from data such as source files, dependencies, built components, build process ephemeral data, and other SBOMs.
	SbomTypeBuild SbomType = "build"
	// SbomTypeDeployed SBOM provides an inventory of software that is present on a system. This may be an assembly of other SBOMs that combines analysis of configuration options, and examination of execution behavior in a (potentially simulated) deployment environment.
	SbomTypeDeployed SbomType = "deployed"
	// SbomTypeDesign SBOM of intended, planned software project or product with included components (some of which may not yet exist) for a new software artifact.
	SbomTypeDesign SbomType = "design"
	// SbomTypeRuntime SBOM generated through instrumenting the system running the software, to capture only components present in the system, as well as external call-outs or dynamically loaded components. In some contexts, this may also be referred to as an "Instrumented" or "Dynamic" SBOM.
	SbomTypeRuntime SbomType = "runtime"
	// SbomTypeSource SBOM created directly from the development environment, source files, and included dependencies used to build an product artifact.
	SbomTypeSource SbomType = "source"
)

// String returns the string representation of SbomType.
func (v SbomType) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid SbomType.
func (v SbomType) IsValid() bool {
	switch v {
	case SbomTypeAnalyzed, SbomTypeBuild, SbomTypeDeployed, SbomTypeDesign, SbomTypeRuntime, SbomTypeSource:
		return true
	default:
		return false
	}
}

// SoftwarePurpose Provides information about the primary purpose of an Element.
type SoftwarePurpose string

const (
	// SoftwarePurposeApplication The Element is a software application.
	SoftwarePurposeApplication SoftwarePurpose = "application"
	// SoftwarePurposeArchive The Element is an archived collection of one or more files (.tar, .zip, etc.).
	SoftwarePurposeArchive SoftwarePurpose = "archive"
	// SoftwarePurposeBom The Element is a bill of materials.
	SoftwarePurposeBom SoftwarePurpose = "bom"
	// SoftwarePurposeConfiguration The Element is configuration data.
	SoftwarePurposeConfiguration SoftwarePurpose = "configuration"
	// SoftwarePurposeContainer The Element is a container image which can be used by a container runtime application.
	SoftwarePurposeContainer SoftwarePurpose = "container"
	// SoftwarePurposeData The Element is data.
	SoftwarePurposeData SoftwarePurpose = "data"
	// SoftwarePurposeDevice The Element refers to a chipset, processor, or electronic board.
	SoftwarePurposeDevice SoftwarePurpose = "device"
	// SoftwarePurposeDeviceDriver The Element represents software that controls hardware devices.
	SoftwarePurposeDeviceDriver SoftwarePurpose = "deviceDriver"
	// SoftwarePurposeDiskImage The Element refers to a disk image that can be written to a disk, booted in a VM, etc. A disk image typically contains most or all of the components necessary to boot, such as bootloaders, kernels, firmware, userspace, etc.
	SoftwarePurposeDiskImage SoftwarePurpose = "diskImage"
	// SoftwarePurposeDocumentation The Element is documentation.
	SoftwarePurposeDocumentation SoftwarePurpose = "documentation"
	// SoftwarePurposeEvidence The Element is the evidence that a specification or requirement has been fulfilled.
	SoftwarePurposeEvidence SoftwarePurpose = "evidence"
	// SoftwarePurposeExecutable The Element is an Artifact that can be run on a computer.
	SoftwarePurposeExecutable SoftwarePurpose = "executable"
	// SoftwarePurposeFile The Element is a single file which can be independently distributed (configuration file, statically linked binary, Kubernetes deployment, etc.).
	SoftwarePurposeFile SoftwarePurpose = "file"
	// SoftwarePurposeFilesystemImage The Element is a file system image that can be written to a disk (or virtual) partition.
	SoftwarePurposeFilesystemImage SoftwarePurpose = "filesystemImage"
	// SoftwarePurposeFirmware The Element provides low level control over a device's hardware.
	SoftwarePurposeFirmware SoftwarePurpose = "firmware"
	// SoftwarePurposeFramework The Element is a software framework.
	SoftwarePurposeFramework SoftwarePurpose = "framework"
	// SoftwarePurposeInstall The Element is used to install software on disk.
	SoftwarePurposeInstall SoftwarePurpose = "install"
	// SoftwarePurposeLibrary The Element is a software library.
	SoftwarePurposeLibrary SoftwarePurpose = "library"
	// SoftwarePurposeManifest The Element is a software manifest.
	SoftwarePurposeManifest SoftwarePurpose = "manifest"
	// SoftwarePurposeModel The Element is a machine learning or artificial intelligence model.
	SoftwarePurposeModel SoftwarePurpose = "model"
	// SoftwarePurposeModule The Element is a module of a piece of software.
	SoftwarePurposeModule SoftwarePurpose = "module"
	// SoftwarePurposeOperatingSystem The Element is an operating system.
	SoftwarePurposeOperatingSystem SoftwarePurpose = "operatingSystem"
	// SoftwarePurposeOther The Element doesn't fit into any of the other categories.
	SoftwarePurposeOther SoftwarePurpose = "other"
	// SoftwarePurposePatch The Element contains a set of changes to update, fix, or improve another Element.
	SoftwarePurposePatch SoftwarePurpose = "patch"
	// SoftwarePurposePlatform The Element represents a runtime environment.
	SoftwarePurposePlatform SoftwarePurpose = "platform"
	// SoftwarePurposeRequirement The Element provides a requirement needed as input for another Element.
	SoftwarePurposeRequirement SoftwarePurpose = "requirement"
	// SoftwarePurposeSource The Element is a single or a collection of source files.
	SoftwarePurposeSource SoftwarePurpose = "source"
	// SoftwarePurposeSpecification The Element is a plan, guideline or strategy how to create, perform or analyze an application.
	SoftwarePurposeSpecification SoftwarePurpose = "specification"
	// SoftwarePurposeTest The Element is a test used to verify functionality on an software element.
	SoftwarePurposeTest SoftwarePurpose = "test"
)

// String returns the string representation of SoftwarePurpose.
func (v SoftwarePurpose) String() string {
	return string(v)
}

// IsValid returns true if the value is a valid SoftwarePurpose.
func (v SoftwarePurpose) IsValid() bool {
	switch v {
	case SoftwarePurposeApplication, SoftwarePurposeArchive, SoftwarePurposeBom, SoftwarePurposeConfiguration, SoftwarePurposeContainer, SoftwarePurposeData, SoftwarePurposeDevice, SoftwarePurposeDeviceDriver, SoftwarePurposeDiskImage, SoftwarePurposeDocumentation, SoftwarePurposeEvidence, SoftwarePurposeExecutable, SoftwarePurposeFile, SoftwarePurposeFilesystemImage, SoftwarePurposeFirmware, SoftwarePurposeFramework, SoftwarePurposeInstall, SoftwarePurposeLibrary, SoftwarePurposeManifest, SoftwarePurposeModel, SoftwarePurposeModule, SoftwarePurposeOperatingSystem, SoftwarePurposeOther, SoftwarePurposePatch, SoftwarePurposePlatform, SoftwarePurposeRequirement, SoftwarePurposeSource, SoftwarePurposeSpecification, SoftwarePurposeTest:
		return true
	default:
		return false
	}
}
